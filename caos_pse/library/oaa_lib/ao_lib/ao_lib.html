<!-- This file was generated by mk_html_help.pro -->
<html>
 
<head>
<TITLE>OAA_LIB-ao_lib Library Help</TITLE>
</head>
 
<body>
<H1>OAA_LIB-ao_lib Library Help</H1>
<P>
This page was created by the IDL library routine 
<CODE>mk_html_help</CODE>.  For more information on 
this routine, refer to the IDL Online Help Navigator 
or type: <P>
<PRE>     ? mk_html_help</PRE><P>
at the IDL command line prompt.<P>
<STRONG>Last modified: </STRONG>Tue May 15 16:15:49 2007.<P>
 
<HR>
 
<A NAME="ROUTINELIST">
<H1>List of Routines</H1></A>
<UL>
<LI><A HREF="#CHOLESKY">CHOLESKY</A>
<LI><A HREF="#CN2">CN2</A>
<LI><A HREF="#CN2_MOMENTUM">CN2_MOMENTUM</A>
<LI><A HREF="#CN2_SETTING">CN2_SETTING</A>
<LI><A HREF="#D0_PAR">D0_PAR</A>
<LI><A HREF="#FRIED_PAR">FRIED_PAR</A>
<LI><A HREF="#ISO_ANGLE">ISO_ANGLE</A>
<LI><A HREF="#JACOBI_POL">JACOBI_POL</A>
<LI><A HREF="#KOLM_COVAR">KOLM_COVAR</A>
<LI><A HREF="#KOLM_MCOVAR">KOLM_MCOVAR</A>
<LI><A HREF="#LLLCCD_OUT">LLLCCD_OUT</A>
<LI><A HREF="#LLLCCD_PROB">LLLCCD_PROB</A>
<LI><A HREF="#MAKE_ORTO_MODES">MAKE_ORTO_MODES</A>
<LI><A HREF="#RANDOMN_COVAR">RANDOMN_COVAR</A>
<LI><A HREF="#VON_COVAR">VON_COVAR</A>
<LI><A HREF="#ZERN">ZERN</A>
<LI><A HREF="#ZERN_DEGREE">ZERN_DEGREE</A>
<LI><A HREF="#ZERN_FT">ZERN_FT</A>
<LI><A HREF="#ZERN_FT_POLAR">ZERN_FT_POLAR</A>
<LI><A HREF="#ZERN_INDEX">ZERN_INDEX</A>
<LI><A HREF="#ZERN_JPOLAR">ZERN_JPOLAR</A>
<LI><A HREF="#ZERN_JRADIAL">ZERN_JRADIAL</A>
<LI><A HREF="#ZERN_ORDER">ZERN_ORDER</A>
</UL><P>
 
<HR>
 
<H1>Routine Descriptions</H1>
<A NAME="CHOLESKY">
<H2>CHOLESKY</H2></A>
<A HREF="#CN2">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
       CHOLESKY

 PURPOSE:
       This procedure makes the cholesky decomposition of
       a positive defined simetric matrix.


 CATEGORY:
       Linear Algebra.

 CALLING SEQUENCE:

       CHOLESKY, L

 INPUTS:
       L:      squared matrix. Matrix to decompose. It is supposed simmetric
               (transpose(L) = L), so only diagonal and upper triangle is
				accessed as input.
               See input of CHOLDC procedure.

 KEYWORDS:
       DOUBLE: if set forces the computation in double precision

 OUTPUTS:
       Matrix. This procedure overwrite on L the lower triangular Cholesky
		factor of the input matrix, so that L ## TRANSPOSE(L) is the original
		simmetric matrix.

 EXAMPLE:
       Cholesky decompsition of a 2 dimensional simmetric matrix:

       C = [[1.2, 0.3], [0.3, -2.3]]
       L = CHOLESKY(C)
       PRINT, C - (L ## TRANSPOSE(L))

 MODIFICATION HISTORY:
       Written by:     A. Riccardi; April, 1995
</PRE><P>
<STRONG>(See ao_lib\cholesky.pro)</STRONG><P>
<HR>
 
<A NAME="CN2">
<H2>CN2</H2></A>
<A HREF="#CHOLESKY">[Previous Routine]</A>
<A HREF="#CN2_MOMENTUM">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
    CN2

    Result = CN2(Z)

    return structure constant value (in m^(-2/3)) at height z (in m) from
    the pupil of imaging system.
</PRE><P>
<STRONG>(See ao_lib\cn2.pro)</STRONG><P>
<HR>
 
<A NAME="CN2_MOMENTUM">
<H2>CN2_MOMENTUM</H2></A>
<A HREF="#CN2">[Previous Routine]</A>
<A HREF="#CN2_SETTING">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
    CN2_MOMENTUM

    Result = CN2_MOMENTUM(Z)

    return CN2(Z)*Z^(Order)

    where Order is set by COMMON BLOCK:
        common cn2_momentum, order
</PRE><P>
<STRONG>(See ao_lib\cn2_momentum.pro)</STRONG><P>
<HR>
 
<A NAME="CN2_SETTING">
<H2>CN2_SETTING</H2></A>
<A HREF="#CN2_MOMENTUM">[Previous Routine]</A>
<A HREF="#D0_PAR">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
    CN2_SETTING

    CN2_SETTING, Which_profile

        Which_profile: string, scalar. String containing the funcion
                       name returning the Cn^2 profile. Three functions
                       are pre-defined:
                       "hv27" - Hufnagel-Valley 27 from Sandler et al., JOSAA,11,925(1994)
                       "hvbl" - adapted from Beckers, ARAA,31,13(1993)
                       "mhv"  - Modified Hufnagel-Valley from Parenti and Sasiela,
                                JOSA,11,288(1994)
                       See below for definition of a user-defined function

    KEYWORDS:

        ALTITUDE:      float, scalar. Site height above sea-level.
                       If not defined, it is set to 0.0.

        ELEVATION:     float, scalar. Height above ground-level of
                       pupil of imaging system. Only for turbulence
                       profiles with surface layers. If not defined,
                       it is set to 0.0.

        R0:            float, scalar. If defined, the profile is
                       rescaled to give R0 as Fried Prameter at
                       wavelength specified by WAVELENGTH keyword.

        WAVELENGTH:    float, scalar. Wavelegth in meters (see R0).
                       If undefined it is set to 0.55e-6m (V band).

        NORMALIZE:     if set rescale turbulence profile to give a
                       normalized turbulence profile (integral=1).

        VERBOSE:       if set print turbulence profile infos.

 USER-DEFINED Cn^2 PROFILE FUNCTION

 function FUNC, z, cn2_settings
                        ; zsl: height from the sea-level
    zsl = z+cn2_settings.altitude+cn2_settings.elevation
                        ; zg: height from the ground
    zg = z+cn2_settings.elevation
    cn2=....            ; usually a function of zsl (free atmosphere),
                        ; zg (boundary layer) and z (dome seeing)
    return, cn2_settings.scale_f*cn2 ; multiply to scale_f to allow r0 scaling
 end

 where z is a vector of height values from the pupil of the optical system in [m]
 and cn2 contains the the structure constant Cn^2 in [m^(-2/3)] at the corresponding
 heights. The structure cn2_settings is defined as follows:
   cn2_settings.name:       string containing the name of the function of the active Cn^2 profile
   cn2_settings.scale_f:    float. Scaling factor to match the requested r0
   cn2_settings.altitude:   float. Height of the ground with respect to the sea level
   cn2_settings.elevation:  float. Elevation of the pupil with respect to the ground level.
                            It is useful when a boundary layer is defined.
   cn2_settings.max_height: float. Maximum height from the sea level of the profile. Above it
                            the Cn^2 profile is considered to be 0.
 Those fields are to be considered as read-only. The user cannot modified the cn2_setting structure
 inside the function. The structure is initialized by the cn2_setting function.

</PRE><P>
<STRONG>(See ao_lib\cn2_setting.pro)</STRONG><P>
<HR>
 
<A NAME="D0_PAR">
<H2>D0_PAR</H2></A>
<A HREF="#CN2_SETTING">[Previous Routine]</A>
<A HREF="#FRIED_PAR">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 D0_PAR

   This function computes the d0 parameter for a laser
   focused at height h [m] at the wavelength wl [m].
   The formula used for d0 is from Tyler.
   Use cn2_setting procedure before use this function
   to set the cn2 profile.

 d0 = d0_par(h, wl, EPS=epsm, MIN_ALT=min_alt, MAX_ALT=max_alt)

 HISTORY

 Written by A. Riccardi (AR)
 Osservatorio Astrofisico di Arcetri, ITALY
 riccardi@arcetri.astro.it
 Please, send me a message if you modify this code.

 14 Mar 2002, AR
  *QROMO is used instead of QROMB for the numerical
   integration giving d0.
  *The max height of the cn2 profile definition is
   now read from the cn2_block common structure.
</PRE><P>
<STRONG>(See ao_lib\d0_par.pro)</STRONG><P>
<HR>
 
<A NAME="FRIED_PAR">
<H2>FRIED_PAR</H2></A>
<A HREF="#D0_PAR">[Previous Routine]</A>
<A HREF="#ISO_ANGLE">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
    FRIED_PAR

    Result = FRIED_PARAM(Wl)

    returns Fried Parameter r_O (in m) at wavelength Wl (in m).
    It uses CN2(Z) turbulence profile.
</PRE><P>
<STRONG>(See ao_lib\fried_par.pro)</STRONG><P>
<HR>
 
<A NAME="ISO_ANGLE">
<H2>ISO_ANGLE</H2></A>
<A HREF="#FRIED_PAR">[Previous Routine]</A>
<A HREF="#JACOBI_POL">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
    ISO_ANGLE

    Return = ISO_ANGLE(Wl)

    return isoplanatic angle (in rad) for turbulence profile CN2 at
    wavelenth Wl (in m).
</PRE><P>
<STRONG>(See ao_lib\iso_angle.pro)</STRONG><P>
<HR>
 
<A NAME="JACOBI_POL">
<H2>JACOBI_POL</H2></A>
<A HREF="#ISO_ANGLE">[Previous Routine]</A>
<A HREF="#KOLM_COVAR">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
       JACOBI_POL

 PURPOSE:
       JACOBI_POL returns the value of the Jacobi Polynomial
		P_N(A,B,X) of degree N and parameters A and B in a vector X
		of points. The Jacobi polynomials are
		orthogonal over the interval (-1,+1) with the weight
		function w(x)=(1-x)^a * (1+x)^b.
		The computation of the polynomial P_N(A,B,X) use the
		recurrence relation:

			P_0(A,B,X) = 1
			P_1(A,B,X) = (a+b+2)/2*X+(A-B)/2

			for N >= 2:
			C0 = 2*N*(A+B+N)*(A+B+2*N-2)
			C1 = (2*N+A+B-2)*(2*N+A+B-1)*(2*N+A+B)*X+
				 +(A^2-B^2)*(2*N+A+B-1)
			C2 = 2*(N+A-1)*(2*N+A+B)*(N+B-1)

			C0*P_N(A,B,X) = C1*P_(N-1)(A,B,X)-C2*P_(N-2)(A,B,X)

 CALLING SEQUENCE:
       Result = JACOBI_POL(N, A, B, X [, JPol1, JPol2])

 INPUTS:
       N:      scalar of type integer or long. N >= 0.
       A:		scalar of type float or double. A > -1. 
       B:      scalar of type float or double. B > -1.
       X:      n-element vector of type float or double.

 OPTIONAL INPUTS:
       JPol1:  n-element vector of type float or double.
				Jacobi polinomial P_(N-1)(A,B,X).
               Not used as input if N <= 1.
       JPol2:  n-element vector of type float or double.
				Jacobi polinomial P_(N-2)(A,B,X).
               Not used as input if N <= 1.

       If JPol1 and JPol2 are given the calculation is faster
		for N >= 2.

 OPTIONAL OUTPUT:
       JPol1:  n-element vector of type float or double.
				Jacobi polinomial P_N(A,B,X).
       JPol2:  n-element vector of type float or double.
				Jacobi polinomial P_(N-1)(A,B,X).
               Not used as output if N = 0.
 REFERENCES:
		Magnus, Oberhettinger, Soni "Formulas and Theorems
			for the Special Function of Mathematical Physics", 1966,
			Sec. 5.2.

 EXAMPLE:

 MODIFICATION HISTORY:
       Written by:     A. Riccardi; October, 1997.
</PRE><P>
<STRONG>(See ao_lib\jacobi_pol.pro)</STRONG><P>
<HR>
 
<A NAME="KOLM_COVAR">
<H2>KOLM_COVAR</H2></A>
<A HREF="#JACOBI_POL">[Previous Routine]</A>
<A HREF="#KOLM_MCOVAR">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME: 
       KOLM_COVAR 
 
 PURPOSE: 
       This function computes the covariance of Zernike polynomial
		coefficients of the wavefront perturbations due to 
		Kolmogorov turbulence.
 
 
 CALLING SEQUENCE: 
 
       Result = KOLM_COVAR(J1, J2) 
 
 INPUTS: 
       J1:     integer scalar. Inedex of Zernike polynomial. J1 >= 2 
       J2:     integer scalar. Inedex of Zernike polynomial. J2 >= 2 
 
 KEYWORD PARAMETERS: 
       DOUBLE: if set, double precision covariance is returned.
				Otherwise, single precision (float).
 
 OUTPUTS: 
       This function returns OPD covariance <a(J1)*a(J2)> where a(J1) and
       a(J2) are J1-th and J2-th Zernike components of wave front 
       perturbations due to Kolmogoroffian turbolence. Covariance is
       in (wavelength)^2*(D/r0)^(5/3) units, where D is the pupil
       diameter and r0 the Fried parameter.
       To have covariance of phase perurbations, use:

           4*pi^2*KOLM_COVAR(J1, J2) = <2*pi*a(J1) * 2*pi*aj(J2)>,

       it is in (D/r0)^(5/3) units.
 
 RESTRICTIONS: 
       J1, J2 >= 2, because piston variance (J1=J2=1) diverges. 
 
 BIBLIOGRAFY: 
           Noll 1976, JOSA, 66, 207.
           Roddier 1990, Opt. Eng., 29, 1174. 
 
 EXAMPLE: 
       Computes the average spatial variance of phase perturbation on a 
       circular pupil of diameter 1.5m due to first 15 Zernike polynomials.
       Suppose r0 = 15cm.

       scale = (150./15.)^(5./3.)
       var = 0.
       FOR i=2,15 DO var = var + KOLM_COVAR(i,i)
       var = (2 * !PI)^2 * scale * var

 MODIFICATION HISTORY: 
       Written by:     A. Riccardi; April, 1995. 
						A. Riccardi; June, 1997. Recursive calculation
							for the Gamma(n+alpha) (n int and alpha
							floating point) to avoid overflow
							in the Gamma Function for large n+alpha.
</PRE><P>
<STRONG>(See ao_lib\kolm_covar.pro)</STRONG><P>
<HR>
 
<A NAME="KOLM_MCOVAR">
<H2>KOLM_MCOVAR</H2></A>
<A HREF="#KOLM_COVAR">[Previous Routine]</A>
<A HREF="#LLLCCD_OUT">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME: 
       KOLM_MCOVAR 
 
 PURPOSE: 
       This function computes OPD covariance matrix of Zernike components of
       wavefront perturbations due to Kolmogorov turbulence. 
 
 CALLING SEQUENCE: 
       Result = KOLM_MCOVAR(Max_index) 
 
 INPUTS: 
       Max_index:  integer saclar. Maximum index of Zernike polynomial used.
                   Max_index >= 2.
 
 KEYWORD PARAMETERS: 
       DOUBLE: if set, the result is double type. Float otherwise.
 
 OUTPUTS: 
       Squared symmetric matrix with Max_index-1 elements per dimension.
       It is the covariance matrix for componets of Zernike polynomial with
       index from 2 to Max_index (see KOLM_COVAR).

           Result(i-2,j-2) = <a(i) * a(j)>     where 2<=i,j<=Max_index

       OPD covariance matrix is in (wavelength)^2*(D/r0)^(5/3) units,
       where D is the pupil diameter and r0 the Fried parameter.
		Return 0 if an error occurred.
 
 RESTRICTIONS: 
       Covariances with Zernike index i=1 or j=1 is not computed
       because piston (j=i=1) Kolmogoroffian variance diverges.
       That's why Max_index >= 2.
 
 PROCEDURE: 
       See: KOLM_COVAR
 
 EXAMPLE: 
       Computes Covariance matrix for first 15 Zernike inexes and print
       variance due to Zernike sferical aberration:

       C = KOLM_MCOVAR(15)
       PRINT, C(11-2, 11-2)
 
 MODIFICATION HISTORY: 
       Written by:     A. Riccardi; April, 1995. 
</PRE><P>
<STRONG>(See ao_lib\kolm_mcovar.pro)</STRONG><P>
<HR>
 
<A NAME="LLLCCD_OUT">
<H2>LLLCCD_OUT</H2></A>
<A HREF="#KOLM_MCOVAR">[Previous Routine]</A>
<A HREF="#LLLCCD_PROB">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>

 prob = lllccd_out(input_phe, r, m[, SEED=seed])

 input_phe: integer matrix: detected photo-electrons before amplification
 g        : float scalar: amplification gain. g=m^r where r is the number of
            amplification registers and m is the multiplication factor per
            register (m>=1, tipically m=1.01)

 SEED:  seed to be used in randomn call. On output it contains the seed returned
        by the randomn call.

 MODIFICATION HISTORY:
 21 March 2003. Written by A. Riccardi, INAF-OAA, Italy
                riccardi@arcetri.astro.it
 22 March 2003. by AR: output converted to long and offset=input added
                It takes into account the detected
</PRE><P>
<STRONG>(See ao_lib\lllccd_out.pro)</STRONG><P>
<HR>
 
<A NAME="LLLCCD_PROB">
<H2>LLLCCD_PROB</H2></A>
<A HREF="#LLLCCD_OUT">[Previous Routine]</A>
<A HREF="#MAKE_ORTO_MODES">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>

 prob = lllccd_prob(x, n, g)

 probability function to obtain x extra-electrons in the avalange when
 n photo-electrons are detected, with gain g. g=m^r where r is the
 number of amplification registers and m is the multiplication factor of
 each register (m>=1.0, m=1.01 tipically).

 n must be integer. if n>170 or (n-1)*log(x/g)

 EXAMPLE:

 probability P(0<=x<1) with n=1 and g=1.01^519

 P=lllccd_prob(0.5, 1, 1.01^519)

 MODIFICATION HISTORY:

 22 March 2003: written by A. Riccardi, INAF-OAA, Italy
                riccardi@arcetri.astro.it
</PRE><P>
<STRONG>(See ao_lib\lllccd_prob.pro)</STRONG><P>
<HR>
 
<A NAME="MAKE_ORTO_MODES">
<H2>MAKE_ORTO_MODES</H2></A>
<A HREF="#LLLCCD_PROB">[Previous Routine]</A>
<A HREF="#RANDOMN_COVAR">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
       MAKE_ORTO_MODES

 PURPOSE:
       This function returns a orthogonal base matrix from the input matrix.   


 CATEGORY:
       Linear Algebra.

 CALLING SEQUENCE:

       RESULT = MAKE_ORTO_MODES(INP_MATR)

 INPUTS:
       INP_MATR: the influence  matrix,M,used to compute the new base orthogonal, B, matrix through
                 the transformation B=M##Q, and  imposed the orthogonal property transpose(B)##B=I.


 OUTPUTS:
       The orthogonal base matrix, B.

 EXAMPLE:
 MODIFICATION HISTORY:
       Written by:     S. Esposito.
       9 March 2006, modified by D.Zanotti(DZ)
       Deleted the automatic transposition of the matrix when an error of input occurred.
       Updated some line codes.
</PRE><P>
<STRONG>(See ao_lib\make_orto_modes.pro)</STRONG><P>
<HR>
 
<A NAME="RANDOMN_COVAR">
<H2>RANDOMN_COVAR</H2></A>
<A HREF="#MAKE_ORTO_MODES">[Previous Routine]</A>
<A HREF="#VON_COVAR">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME: 
       RANDOMN_COVAR
 
 PURPOSE: 
       This function returns a sample of zero mean jointly
       gaussian random variables by the Cholesky decomposition
       of their covariance matrix.

 
 CATEGORY: 
       Statistics. 
 
 CALLING SEQUENCE: 

       Result = RANDOMN_COVAR(L,R) 
 
 INPUTS: 
       L:      squared matrix. Cholesky factor of covariance
               matrix from CHOLESKY function. The covariance
               matrix C is:
                   C = transpose(L)#L

 OPTIONAL INPUTS:
       R:      integer or long scalar. Number of realizations.
               If not defined one realization is returned.
 
 KEYWORD PARAMETERS: 
       SEED:   long type variable. Random generation seed.
               See RANDOMU function.
 
 OUTPUTS: 
       Vector. This function returns a sample of zero mean jointly
       gaussian random variables with statistics from L.
       If L is double type matrix, double vector is
       returned. Otherwise float.

               Return = L ## RANDOMN(seed,r,n)

       where n is the dimension of L.
 
 OPTIONAL OUTPUTS: 
       If SEED variable is specified, it is updated. See RANDOMU function.
 
 TROUBLES: 
       Even if double type L is used, RANDOMN returns
       a float type vector that is converted to double type one. 
 
 EXAMPLE: 
       Create a plot of probability density function of the sum
       of two jointly gaussian variables with M mean and C covariance.

       C = [[1.2, 0.3], [0.3, 2.3]]
       M = [12.1, 25.7]
       L = CHOLESKY(C)
       seed = 1L
       A = fltarr(500, /NOZERO)
       FOR i=0,499 DO A(i) = TOTAL(RANDOMN_COVAR(L, SEED=seed) + M)
       HISTOGRAM(A)
 
 MODIFICATION HISTORY: 
       Written by:     A. Riccardi; April, 1995
</PRE><P>
<STRONG>(See ao_lib\randomn_covar.pro)</STRONG><P>
<HR>
 
<A NAME="VON_COVAR">
<H2>VON_COVAR</H2></A>
<A HREF="#RANDOMN_COVAR">[Previous Routine]</A>
<A HREF="#ZERN">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME: 
       VON_COVAR 
 
 PURPOSE: 
       This function computes covariance of zernike components of
       wave front perturbations due to Von-Karmann turbolence.
 
 CATEGORY: 
       Optics. 
 
 CALLING SEQUENCE: 
 
       Result = VON_COVAR(J1, J2, L0) 
 
 INPUTS: 
       J1:     integer scalar. Inedex of Zernike polynomial. J1 >= 1
       J2:     integer scalar. Inedex of Zernike polynomial. J2 >= 1
		L0:		float or double. Outer-scale value in pupil diameter
				units.
 
 KEYWORD PARAMETERS: 
       DOUBLE: if set, forces double type covariance. Float therwise.
		EPS:	float or double scalar. relative precision of computation.
				If undefined EPS=1.e-7.
 
 OUTPUTS: 
       This function returns covariance <a(J1)*a(J2)> where a(J1) and
       a(J2) are J1-th and J2-th Zernike components of wave front 
       perturbations due to Von-Karman turbolence. Covariance is
       in (wave-length)^2*(D/r0)^(5/3) units, where D is the pupil
       diameter and r0 the Fried parameter (r0 for Kolmogoroffian
		turbolence).
       To have covariance of phase perurbations, use:

           4*pi^2*VON_COVAR(J1, J2) = <2*pi*a(J1) * 2*pi*aj(J2)>,

       it is in (D/r0)^(5/3) units.
 
 PROCEDURE: 
       See:
           Winker D. M., 1991, JOSA, 8, 1569.
           Takato N. and Yamaguchi I., 1995, JOSA, 12, 958
 
 EXAMPLE: 
       Computes the average spatial variance of phase perturbation on a 
       circular pupil of diameter 1.5m dues to first 15 Zernike aberrations.
       Suppose r0 = 15cm, L0=40m

       scale = (150./15.)^(5./3.)
		L0norm= (40./1.5)
       var = 0.
       FOR i=2,15 DO var = var + VON_COVAR(i,i,L0norm)
       var = 4 * !PI * var * scale
       Strhel_Ratio = EXP(-var)

 MODIFICATION HISTORY: 
       Written by:     A. Riccardi; July, 1995. 
</PRE><P>
<STRONG>(See ao_lib\von_covar.pro)</STRONG><P>
<HR>
 
<A NAME="ZERN">
<H2>ZERN</H2></A>
<A HREF="#VON_COVAR">[Previous Routine]</A>
<A HREF="#ZERN_DEGREE">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
       ZERN

 PURPOSE:
       The ZERN function returns the value of J-th Zernike polynomial
       in the points of coordinates X,Y. The output is of the same type
		as the X and Y vectors. The function convert X,Y
		coordinates in polar coordinates and call ZERN_JPOLAR function.

 CALLING SEQUENCE:
       Result = ZERN(J, X, Y)

 INPUTS:
       J:      scalar of type integer or long. Index of the polynomial,
				J >= 1.
       X:      n-element vector of type float or double. X coordinates.
       Y:		n-element vector of type float or double. Y coordinates.

 MODIFICATION HISTORY:
       Written by:    A. Riccardi; March, 1995.
</PRE><P>
<STRONG>(See ao_lib\zern.pro)</STRONG><P>
<HR>
 
<A NAME="ZERN_DEGREE">
<H2>ZERN_DEGREE</H2></A>
<A HREF="#ZERN">[Previous Routine]</A>
<A HREF="#ZERN_FT">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:           
       ZERN_DEGREE           
           
 PURPOSE:          
       ZERN_DEGREE calculates the radial degree n and azimuthal  
       frequency m of Zernike polynomial of index j.   
           
 CATEGORY:           
       Optics.          
           
 CALLING SEQUENCE:           
            
       ZERN_DEGREE, J, N, M           
           
 MODIFICATION HISTORY:           
       Written by:     A. Riccardi; March, 1995.           
</PRE><P>
<STRONG>(See ao_lib\zern_degree.pro)</STRONG><P>
<HR>
 
<A NAME="ZERN_FT">
<H2>ZERN_FT</H2></A>
<A HREF="#ZERN_DEGREE">[Previous Routine]</A>
<A HREF="#ZERN_FT_POLAR">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
       ZERN_FT

 PURPOSE:
       ZERN_FT returns the value of j-th Zernike polynomial
       fourier transform in a point of frequency fx,fy.
       (We use Noll formulation of Zernike polynomials)

 CATEGORY:
       Special polynomial

 CALLING SEQUENCE:

       Result = ZERN_FT(J, Fx, Fy)

 INPUTS:
       J:      index of the polynomial, integer J >= 1
       Fx:     frequency to evaluate
       Fy:

 OUTPUTS:
       ZERN_FT returns the value of j-th Zernike polynomial
       fourier transform in the point of requency Fx,Fy.
       On error return 0.

 EXAMPLE:
       Evaluate Zernike x coma fourier transform in fx,fy. Enter:

           Result = ZERN_FT(8, fx, fy)

 MODIFICATION HISTORY:
       Written by:     A. Riccardi; March, 1995.
</PRE><P>
<STRONG>(See ao_lib\zern_ft.pro)</STRONG><P>
<HR>
 
<A NAME="ZERN_FT_POLAR">
<H2>ZERN_FT_POLAR</H2></A>
<A HREF="#ZERN_FT">[Previous Routine]</A>
<A HREF="#ZERN_INDEX">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
       ZERN_FT_POLAR

 PURPOSE:
       ZERN_FT_POLAR returns the value of j-th Zernike polynomial
       fourier transform in a frequency of polar coordinates k,phi.
       (We use Noll formulation of Zernike polynomials)

 CATEGORY:
       Special polynomial

 CALLING SEQUENCE:

       Result = ZERN_FT_POLAR(J, K, Phi)

 INPUTS:
       J:      index of the polynomial, integer J >= 1
       K:      frequency to evaluate (polar coord.)
       Phi:

 OUTPUTS:
       ZERN_FT_POLAR returns the value of j-th Zernike polynomial
       fourier tranform in the frequency of polar coordinates k, phi.
       On error return 0.

 EXAMPLE:
       Evaluate Zernike x coma fourier transform in kappa, phi. Enter:

            Result = ZERN_FT_POLAR(8, kappa, phi)

 MODIFICATION HISTORY:
       Written by:     A. Riccardi; March, 1995.
</PRE><P>
<STRONG>(See ao_lib\zern_ft_polar.pro)</STRONG><P>
<HR>
 
<A NAME="ZERN_INDEX">
<H2>ZERN_INDEX</H2></A>
<A HREF="#ZERN_FT_POLAR">[Previous Routine]</A>
<A HREF="#ZERN_JPOLAR">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME: 
       ZERN_INDEX 
 
 PURPOSE: 
       ZERN_INDEX calculates the index of a zernike polynomial
       from radial degree N and azimuthal frequency M. If M is not
       zero there are two possible index value, even and odd, with
       index_1=j and index_2=j+1. In this case (M is not 0)
       Zernike_index returns the minor value (j).
 
 CATEGORY: 
       Special polynomial. 
 
 CALLING SEQUENCE: 

       Result = ZERN_INDEX(N, M) 
 
 INPUTS: 
       N:  radial degree. Integer, N>=0.
       M:  azimuthal frequency. Integer, 0<=M<=N and N-M even 
 
 MODIFICATION HISTORY: 
       Written by:     A. Riccardi; April, 1995.
</PRE><P>
<STRONG>(See ao_lib\zern_index.pro)</STRONG><P>
<HR>
 
<A NAME="ZERN_JPOLAR">
<H2>ZERN_JPOLAR</H2></A>
<A HREF="#ZERN_INDEX">[Previous Routine]</A>
<A HREF="#ZERN_JRADIAL">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
       ZERN_JPOLAR

 PURPOSE:
       ZERN_JPOLAR returns the value of j-th Zernike polynomial
       in a point of polar coordinates r,theta.
       (We use Noll formulation of Zernike polynomials)

 CATEGORY:
       Special polynomial

 CALLING SEQUENCE:

       Result = ZERN_JPOLAR(J, R, Theta)

 INPUTS:
       J:      index of the polynomial, integer J >= 1
       R:      point to evaluate (polar coord.)
       Theta:

 OUTPUTS:
       ZERN_POLAR returns the value of j-th Zernike polynomial
       in the point of polar coordinates r, theta.
       If r>1 then return 0. On error return 0.

 EXAMPLE:
       Evaluate Zernike x coma in rho, theta. Enter:

            Result = ZERN_JPOLAR(8, rho, theta)

 MODIFICATION HISTORY:
       Written by:     A. Riccardi; March, 1995.
</PRE><P>
<STRONG>(See ao_lib\zern_jpolar.pro)</STRONG><P>
<HR>
 
<A NAME="ZERN_JRADIAL">
<H2>ZERN_JRADIAL</H2></A>
<A HREF="#ZERN_JPOLAR">[Previous Routine]</A>
<A HREF="#ZERN_ORDER">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
       ZERN_JRADIAL

 PURPOSE:
       ZERN_JRADIAL returns the value of the radial portion R(N,M,Rho)
		of the Zernike polynomial of radial degree N and azimuthal
		frequency M in a vector R of radial points.
		The radial Zernike polynomial is defined in the range (0,1)
		and is computed as:

			R(N,M,Rho) = Rho^M * P_[(N-M)/2](0,M,2*Rho^2-1)

		where P_k(a,b,x) is the Jacobi Polynomial of degree k (see
		JACOBI_POL)

 CALLING SEQUENCE:
       Result = ZERNKE_JRADIAL(N, M, Rho [, Jpol1, JPol2])

 INPUTS:
       N:      scalar of type integer or long. N >= 0.
       M:      scalar of type integer or long. 0 <= M <= N and M-N even.
       Rho:    n_elements vector of type float or double.

 OPTIONAL INPUTS:
		JPol1:	n_elements vector of type float or double.
				Jacobi polinomial P_[(N-M)/2-1](0,M,2*Rho^2-1).
				Not used as input if (N-M)/2 <= 1.
		JPol2:	n_elements vector of type float or double.
				Jacobi polinomial P_[(N-M)/2-2](0,M,2*Rho^2-1).
				with k=(N-M)/2-2. Not used if (N-M)/2-2 <= 1.
				Not used as input if (N-M)/2 <= 1.

		If JPol1 and JPol2 are given the calculation is faster
		for (N-M)/2 >= 2.

 OPTIONAL OUTPUTS:
		JPol1:  n-element vector of type float or double.
				Jacobi polinomial P_[(N-M)/2](0,M,2*Rho^2-1).
				Not used as input if N <= 1.
		JPol2:  n-element vector of type float or double.
				Jacobi polinomial P_[(N-M)/2-1](0,M,2*Rho^2-1).
               Not used as output if N = 0.

 REFERENCES:
       Magnus, Oberhettinger, Soni "Formulas and Theorems
           for the Special Function of Mathematical Physics", 1966,
           Sec. 5.2.
		Born, Wolf, "Optics"
		Noll 1976, JOSA, 66, 207.

 MODIFICATION HISTORY:
       Written by:     A. Riccardi; October, 1997.
</PRE><P>
<STRONG>(See ao_lib\zern_jradial.pro)</STRONG><P>
<HR>
 
<A NAME="ZERN_ORDER">
<H2>ZERN_ORDER</H2></A>
<A HREF="#ZERN_JRADIAL">[Previous Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
   Result = ZERN_ORDER(Nmax)

   returns a vector of Zernike polynomial indexes from 2 to
   ZERNIKE_INXDEX(Nmax,Nmax) ordered by azimuthal frequency
   (see Roddier 90, Opt. Eng., 29, 1174). Nmax must be >=1
</PRE><P>
<STRONG>(See ao_lib\zern_order.pro)</STRONG><P>
<HR>
 
</body>
</html>
